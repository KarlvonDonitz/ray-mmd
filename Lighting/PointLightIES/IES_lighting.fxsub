#include "../../../ray.conf"
#include "../../../ray_advanced.conf"
#include "../../../shader/math.fxsub"
#include "../../../shader/common.fxsub"
#include "../../../shader/Color.fxsub"
#include "../../../shader/Packing.fxsub"
#include "../../../shader/gbuffer.fxsub"
#include "../../../shader/gbuffer_sampler.fxsub"
#include "../../../shader/BRDF.fxsub"
#include "../../../shader/arealight.fxsub"

#if SHADOW_MAP_FROM > 0
#	include "../../../shader/Shadow.fxsub"
#endif

float3 mPosition : CONTROLOBJECT<string name = "(self)"; string item = "Position";>;
float3 mDirection : CONTROLOBJECT<string name = "(self)"; string item = "Direction";>;

float mHP : CONTROLOBJECT<string name = "(self)"; string item = "H+";>;
float mSP : CONTROLOBJECT<string name = "(self)"; string item = "S+";>;
float mVP : CONTROLOBJECT<string name = "(self)"; string item = "V+";>;
float mVM : CONTROLOBJECT<string name = "(self)"; string item = "V-";>;
float mBlink : CONTROLOBJECT<string name = "(self)"; string item = "Blink";>;
float mRangeP : CONTROLOBJECT<string name = "(self)"; string item = "Range+";>;
float mRangeM : CONTROLOBJECT<string name = "(self)"; string item = "Range-";>;
float mHardnessP : CONTROLOBJECT<string name = "(self)"; string item = "Hardness";>;
float mTemperatureP : CONTROLOBJECT<string name = "(self)"; string item = "Temperature+";>;
float mTemperatureM : CONTROLOBJECT<string name = "(self)"; string item = "Temperature-";>;
float mAttenuationBulbP : CONTROLOBJECT<string name = "(self)"; string item = "AttenuationBulb+";>;
float mAttenuationBulbM : CONTROLOBJECT<string name = "(self)"; string item = "AttenuationBulb-";>;
float mMultiLightP : CONTROLOBJECT<string name = "ray_controller.pmx"; string item = "MultiLight+";>;
float mMultiLightM : CONTROLOBJECT<string name = "ray_controller.pmx"; string item = "MultiLight-";>;

static const float LightHardness = lerp(shadowHardness.x, shadowHardness.y, mHardnessP);
static const float LightRange = lerp(lerp(lightRangeParams.x, lightRangeParams.z, mRangeP), lightRangeParams.y, mRangeM);
static const float LightBlink = saturate(1 - SmoothTriangleWave(time * mBlink * 10));
static const float LightAttenuationBulb = lerp(lerp(lightAttenuationBulbParams.x, lightAttenuationBulbParams.z, mAttenuationBulbP), lightAttenuationBulbParams.y, mAttenuationBulbM);
static const float LightIntensity = lerp(lerp(lightIntensityParams.x, lightIntensityParams.z, mVP), lightIntensityParams.y, mVM);
static const float LightIntensity2 = lerp(lerp(mLightIntensityMin, mLightIntensityMax, mMultiLightP), 0, mMultiLightM);
static const float LightTemperature = lerp(lerp(lightTemperatureLimits.x, lightTemperatureLimits.y, mTemperatureP), lightTemperatureLimits.z, mTemperatureM);

static const float3 LightPosition = mPosition;
static const float3 LightDirection = normalize(mDirection - mPosition);
static const float3 LightColor = float3(mHP, mSP, LightIntensity * LightIntensity2 * LightBlink);

static const float3 viewLightPosition = mul(float4(LightPosition, 1), matView).xyz;
static const float3 viewLightDirection = normalize(mul(LightDirection, (float3x3)matView));

#if SHADOW_MAP_FROM > 0
#if SHADOW_MAP_QUALITY == 0
#   define SHADOW_MAP_WIDTH 256
#   define SHADOW_MAP_HEIGHT 512
#elif SHADOW_MAP_QUALITY == 1
#   define SHADOW_MAP_WIDTH 512
#   define SHADOW_MAP_HEIGHT 1024
#elif SHADOW_MAP_QUALITY >= 2
#   define SHADOW_MAP_WIDTH 1024
#   define SHADOW_MAP_HEIGHT 2048
#elif SHADOW_MAP_QUALITY >= 3
#   define SHADOW_MAP_WIDTH 2048
#   define SHADOW_MAP_HEIGHT 4096
#else
#   define SHADOW_MAP_WIDTH 256
#   define SHADOW_MAP_HEIGHT 512
#endif

texture ShadowMap: OFFSCREENRENDERTARGET <
	string Description = "Shadow Rendering for PointLightIES";
	int2 Dimensions = {SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT};
	string Format = "G32R32F";
	float4 ClearColor = { 1, 1, 1, 1 };
	float ClearDepth = 1.0;
	string DefaultEffect = 
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller.pmx=hide;"
		"*editor*.pmx=hide;"
		"*.pmx = ../ies_shadow.fx;"
		"*.pmd = ../ies_shadow.fx;"
		"* = hide";
>;
sampler ShadowMapSamp = sampler_state {
	texture = <ShadowMap>;
	MinFilter = POINT;	MagFilter = LINEAR;	MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};

static float2 ShadowmapOffset  = 0.5 / float2(SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT);
static float2 ShadowmapOffset2 = 1.0 / float2(SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT);

float ShadingShadow(MaterialParam material, float3 viewPosition)
{
	float3 P = mul(float4(viewPosition, 1), matViewInverse).xyz;
	float3 L = P - LightPosition;

	float linearDepth = length(L);
	float depth = (mPointLightFar - (mPointLightFar / linearDepth) * mPointLightNear) / (mPointLightFar - mPointLightNear);

	float2 shadow = 0.0;
	float2 coord = CalcDualShadowCoord(L / linearDepth, SHADOW_MAP_HEIGHT);

	[unroll]
	for (int x = -sampleRadius; x <= sampleRadius; x++) 
	{
		[unroll]
		for (int y = -sampleRadius; y <= sampleRadius; y++)
		{
			float2 pos = coord + float2(x, y) * ShadowmapOffset2;
			shadow += tex2Dlod(ShadowMapSamp, float4(pos, 0, 0)).rg * sampleKernel[sampleRadius + x] * sampleKernel[sampleRadius + y];
		}
	}

	return ChebyshevUpperBound(shadow, depth, 1e-4, LightHardness);
}
#endif

texture IESTexture<string ResourceName = LIGHT_PARAMS_FILE; int Miplevels = 1;>; 
sampler IESTextureSamp = sampler_state
{
	texture = <IESTexture>;
	MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
	AddressU  = CLAMP; AddressV = CLAMP;
};

float3 ComputeIESLightProfile1D(float3 L, float3 Ld)
{
	L = mul(L, (float3x3)matViewInverse);
	float angle = (1 - acos(dot(L, Ld)) / PI);
	return tex2Dlod(IESTextureSamp, float4(angle, 0, 0, 0)).rgb;
}

void ShadingMaterial(MaterialParam material, float3 P, float3 
