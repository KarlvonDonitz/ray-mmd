#if PCSS_QUALITY == 1
#	define SHADOW_BLOCKER_COUNT 15
#	define SHADOW_POISSON_COUNT 36
#	define SHADOW_BLUR_COUNT 6
#elif PCSS_QUALITY == 2
#	define SHADOW_BLOCKER_COUNT 32
#	define SHADOW_POISSON_COUNT 64
#	define SHADOW_BLUR_COUNT 6
#else
#	define SHADOW_BLOCKER_COUNT 15
#	define SHADOW_POISSON_COUNT 36
#	define SHADOW_BLUR_COUNT 6
#endif

static float4x4 matLightProject = CreateOrthoProject(2, 2, mPSSMDepthZMin, mPSSMDepthZMax);
static float4x4 matLightView = CreateLightViewMatrix(MainLightDirection, -MainLightDirection, mLightDistance);
static float4x4 matLightViewProject = mul(matLightView, matLightProject);
static float4x4 matLightViewFromCameraView = mul(matViewInverse, matLightView);
static float4x4 matLightProjectFromCameraView = mul(matViewInverse, matLightViewProject);
static float4x4 lightCropParams = CreateLightCropParams(matLightViewFromCameraView, SHADOW_MAP_SIZE);

static const float2 Poisson15[15] =
{
	float2(0.545455, 0),
	float2(0.168555, 0.518758),
	float2(-0.441282, 0.32061),
	float2(-0.441282, -0.32061),
	float2(0.168555, -0.518758),
	float2(1, 0),
	float2(0.809017, 0.587785),
	float2(0.309017, 0.951057),
	float2(-0.309017, 0.951056),
	float2(-0.809017, 0.587785),
	float2(-1, -8.74228e-08),
	float2(-0.809017, -0.587785),
	float2(-0.309017, -0.951057),
	float2(0.309017, -0.951056),
	float2(0.809017, -0.587785)
};
static const float2 Poisson32[32] = {
	float2(0.06407013, 0.05409927),
	float2(0.7366577, 0.5789394),
	float2(-0.6270542, -0.5320278),
	float2(-0.4096107, 0.8411095),
	float2(0.6849564, -0.4990818),
	float2(-0.874181, -0.04579735),
	float2(0.9989998, 0.0009880066),
	float2(-0.004920578, -0.9151649),
	float2(0.1805763, 0.9747483),
	float2(-0.2138451, 0.2635818),
	float2(0.109845, 0.3884785),
	float2(0.06876755, -0.3581074),
	float2(0.374073, -0.7661266),
	float2(0.3079132, -0.1216763),
	float2(-0.3794335, -0.8271583),
	float2(-0.203878, -0.07715034),
	float2(0.5912697, 0.1469799),
	float2(-0.88069, 0.3031784),
	float2(0.5040108, 0.8283722),
	float2(-0.5844124, 0.5494877),
	float2(0.6017799, -0.1726654),
	float2(-0.5554981, 0.1559997),
	float2(-0.3016369, -0.3900928),
	float2(-0.5550632, -0.1723762),
	float2(0.925029, 0.2995041),
	float2(-0.2473137, 0.5538505),
	float2(0.9183037, -0.2862392),
	float2(0.2469421, 0.6718712),
	float2(0.3916397, -0.4328209),
	float2(-0.03576927, -0.6220032),
	float2(-0.04661255, 0.7995201),
	float2(0.4402924, 0.3640312),
};
static const float2 Poisson36[36] =
{
	float2(0.368421, 0),
	float2(0.18421, 0.319062),
	float2(-0.184211, 0.319062),
	float2(-0.368421, -3.22084e-08),
	float2(-0.18421, -0.319062),
	float2(0.184211, -0.319062),
	float2(0.684211, 0),
	float2(0.592544, 0.342105),
	float2(0.342105, 0.592544),
	float2(-2.99078e-08, 0.684211),
	float2(-0.342105, 0.592544),
	float2(-0.592544, 0.342105),
	float2(-0.684211, -5.98156e-08),
	float2(-0.592544, -0.342105),
	float2(-0.342105, -0.592544),
	float2(8.15913e-09, -0.684211),
	float2(0.342106, -0.592544),
	float2(0.592544, -0.342105),
	float2(1, 0),
	float2(0.939693, 0.34202),
	float2(0.766044, 0.642788),
	float2(0.5, 0.866025),
	float2(0.173648, 0.984808),
	float2(-0.173648, 0.984808),
	float2(-0.5, 0.866025),
	float2(-0.766045, 0.642787),
	float2(-0.939693, 0.34202),
	float2(-1, -8.74228e-08),
	float2(-0.939693, -0.34202),
	float2(-0.766044, -0.642788),
	float2(-0.5, -0.866025),
	float2(-0.173648, -0.984808),
	float2(0.173649, -0.984808),
	float2(0.5, -0.866025),
	float2(0.766045, -0.642787),
	float2(0.939693, -0.34202)
};
static const float2 Poisson64[64] = {
	float2(0.0617981, 0.07294159),
	float2(0.6470215, 0.7474022),
	float2(-0.5987766, -0.7512833),
	float2(-0.693034, 0.6913887),
	float2(0.6987045, -0.6843052),
	float2(-0.9402866, 0.04474335),
	float2(0.8934509, 0.07369385),
	float2(0.1592735, -0.9686295),
	float2(-0.05664673, 0.995282),
	float2(-0.1203411, -0.1301079),
	float2(0.1741608, -0.1682285),
	float2(-0.09369049, 0.3196758),
	float2(0.185363, 0.3213367),
	float2(-0.1493771, -0.3147511),
	float2(0.4452095, 0.2580113),
	float2(-0.1080467, -0.5329178),
	float2(0.1604507, 0.5460774),
	float2(-0.4037193, -0.2611179),
	float2(0.5947998, -0.2146744),
	float2(0.3276062, 0.9244621),
	float2(-0.6518704, -0.2503952),
	float2(-0.3580975, 0.2806469),
	float2(0.8587891, 0.4838005),
	float2(-0.1596546, -0.8791054),
	float2(-0.3096867, 0.5588146),
	float2(-0.5128918, 0.1448544),
	float2(0.8581337, -0.424046),
	float2(0.1562584, -0.5610626),
	float2(-0.7647934, 0.2709858),
	float2(-0.3090832, 0.9020988),
	float2(0.3935608, 0.4609676),
	float2(0.3929337, -0.5010948),
	float2(-0.8682281, -0.1990303),
	float2(-0.01973724, 0.6478714),
	float2(-0.3897587, -0.4665619),
	float2(-0.7416366, -0.4377831),
	float2(-0.5523247, 0.4272514),
	float2(-0.5325066, 0.8410385),
	float2(0.3085465, -0.7842533),
	float2(0.8400612, -0.200119),
	float2(0.6632416, 0.3067062),
	float2(-0.4462856, -0.04265022),
	float2(0.06892014, 0.812484),
	float2(0.5149567, -0.7502338),
	float2(0.6464897, -0.4666451),
	float2(-0.159861, 0.1038342),
	float2(0.6455986, 0.04419327),
	float2(-0.7445076, 0.5035095),
	float2(0.9430245, 0.3139912),
	float2(0.0349884, -0.7968109),
	float2(-0.9517487, 0.2963554),
	float2(-0.7304786, -0.01006928),
	float2(-0.5862702, -0.5531025),
	float2(0.3029106, 0.09497032),
	float2(0.09025345, -0.3503742),
	float2(0.4356628, -0.0710125),
	float2(0.4112572, 0.7500054),
	float2(0.3401214, -0.3047142),
	float2(-0.2192158, -0.6911137),
	float2(-0.4676369, 0.6570358),
	float2(0.6295372, 0.5629555),
	float2(0.1253822, 0.9892166),
	float2(-0.1154335, 0.8248222),
	float2(-0.4230408, -0.7129914),
};

float2 FindBlocker(sampler _ShadowTex, float2 uv, float depth, float searchRadius)
{
    float blockerWeight = 0;
    float blockerDepthSum = 0.0;

    for (int i = 0; i < SHADOW_BLOCKER_COUNT; i++)
    {
#if SHADOW_BLOCKER_COUNT == 15
		float sampleDepth = tex2Dlod(_ShadowTex, float4(uv + Poisson15[i] * searchRadius, 0, 0)).r;
#elif SHADOW_BLOCKER_COUNT == 32
		float sampleDepth = tex2Dlod(_ShadowTex, float4(uv + Poisson32[i] * searchRadius, 0, 0)).r;
#endif
        if (sampleDepth < depth)
        {
            blockerDepthSum += sampleDepth;
            blockerWeight++;
        }
    }

    return float2(blockerDepthSum / max(1e-5, blockerWeight), blockerWeight);
}

float2 Rotate(float2 pos, float2 rotation)
{
	return float2(pos.x * rotation.x - pos.y * rotation.y, pos.y * rotation.x + pos.x * rotation.y);
}

float ShadowPCF(sampler _ShadowTex, float2 uv, float radius, float receiverDepth, float2 rotation, float lightSize)
{
#if PCSS_QUALITY > 0
	float2 blocker = FindBlocker(_ShadowTex, uv, receiverDepth, lightSize / SHADOW_MAP_SIZE);

	float depth = receiverDepth / mPSSMDepthZMax;
	float avgBlockerDepth = blocker.x / mPSSMDepthZMax;

	float penumbraRatio = (depth - avgBlockerDepth) / avgBlockerDepth * (lightSize * 5);
	float filterSize = max(penumbraRatio / depth, 1) * radius;
#else
	float filterSize = 2 * radius;
	float2 blocker = 1;
#endif

	[branch]
    if (blocker.y <= 0)
    {
		return 1;
    }

	float shadow = 0.0;

	[unroll]
	for (int i = 0; i < SHADOW_POISSON_COUNT; i+=4) 
	{
		float2 samplePoints[4];
#if SHADOW_POISSON_COUNT == 32
		samplePoints[0] = Rotate(Poisson32[i] * filterSize, rotation);
		samplePoints[1] = Rotate(Poisson32[i+1] * filterSize, rotation);
		samplePoints[2] = Rotate(Poisson32[i+2] * filterSize, rotation);
		samplePoints[3] = Rotate(Poisson32[i+3] * filterSize, rotation);
#elif SHADOW_POISSON_COUNT == 36
		samplePoints[0] = Rotate(Poisson36[i] * filterSize, rotation);
		samplePoints[1] = Rotate(Poisson36[i+1] * filterSize, rotation);
		samplePoints[2] = Rotate(Poisson36[i+2] * filterSize, rotation);
		samplePoints[3] = Rotate(Poisson36[i+3] * filterSize, rotation);
#elif SHADOW_POISSON_COUNT == 64
		samplePoints[0] = Rotate(Poisson64[i] * filterSize, rotation);
		samplePoints[1] = Rotate(Poisson64[i+1] * filterSize, rotation);
		samplePoints[2] = Rotate(Poisson64[i+2] * filterSize, rotation);
		samplePoints[3] = Rotate(Poisson64[i+3] * filterSize, rotation);
#endif
		
		float4 sampleLinearDepth;
		sampleLinearDepth[0] = tex2Dlod(_ShadowTex, float4(uv + samplePoints[0], 0, 0)).r;
		sampleLinearDepth[1] = tex2Dlod(_ShadowTex, float4(uv + samplePoints[1], 0, 0)).r;
		sampleLinearDepth[2] = tex2Dlod(_ShadowTex, float4(uv + samplePoints[2], 0, 0)).r;
		sampleLinearDepth[3] = tex2Dlod(_ShadowTex, float4(uv + samplePoints[3], 0, 0)).r;

		shadow += sum(saturate(exp(20 * (sampleLinearDepth - receiverDepth))));
	}
    

	return shadow / SHADOW_POISSON_COUNT;
}

float ShadingShadow(MaterialParam material, float3 viewPosition, float angle)
{
	float4 proj = mul(float4(viewPosition, 1), matLightProjectFromCameraView);

	float4 lightPPos01 = proj.xyxy * float4(lightCropParams[0].xy, lightCropParams[1].xy) + float4(lightCropParams[0].zw, lightCropParams[1].zw);
	float4 lightPPos23 = proj.xyxy * float4(lightCropParams[2].xy, lightCropParams[3].xy) + float4(lightCropParams[2].zw, lightCropParams[3].zw);

	float4 lightCoord01 = PosToCoord(lightPPos01);
	float4 lightCoord23 = PosToCoord(lightPPos23);

	float4 lightPPos0 = float4(lightCoord01.xy, min2(float2(1, 1) - abs(lightPPos01.xy)), 0);
	float4 lightPPos1 = float4(lightCoord01.zw, min2(float2(1, 1) - abs(lightPPos01.zw)), 1);
	float4 lightPPos2 = float4(lightCoord23.xy, min2(float2(1, 1) - abs(lightPPos23.xy)), 2);
	float4 lightPPos3 = float4(lightCoord23.zw, min2(float2(1, 1) - abs(lightPPos23.zw)), 3);

	float4 coord = lightPPos3;
	if (lightPPos2.z > 0) { coord = lightPPos2; }
	if (lightPPos1.z > 0) { coord = lightPPos1; }
	if (lightPPos0.z > 0) { coord = lightPPos0; }
	clip(coord.z);

	float receiverDepth = dot(float4(viewPosition, 1), matLightViewFromCameraView._13_23_33_43);
	receiverDepth -= material.linearDepth * 0.0035 + max(0, material.linearDepth - 100) * 0.007;

	coord.xy += 0.5 / float(SHADOW_MAP_SIZE);

	[branch]
	if (coord.w == 0)
		clip(tex2Dlod(_PSSM1_LinearSampler, float4(coord.xy, 0, 0)).r - 1e-5);
	else if (coord.w == 1)
		clip(tex2Dlod(_PSSM2_LinearSampler, float4(coord.xy, 0, 0)).r - 1e-5);
	else if (coord.w == 2)
		clip(tex2Dlod(_PSSM3_LinearSampler, float4(coord.xy, 0, 0)).r - 1e-5);
	else
		clip(tex2Dlod(_PSSM4_LinearSampler, float4(coord.xy, 0, 0)).r - 1e-5);

	float shadow = 0;
	float radius = 1.0 / SHADOW_MAP_SIZE;
	float lightSize = SHADOW_MAP_SIZE * 0.01; 
	float2 rotation = float2(cos(angle), sin(angle));

	[branch]
	if (coord.w == 0)
		shadow = ShadowPCF(_PSSM1_LinearSampler, coord.xy, radius, receiverDepth, rotation, lightSize);
	else if (coord.w == 1)
		shadow = ShadowPCF(_PSSM2_LinearSampler, coord.xy, radius / 2, receiverDepth, rotation, lightSize);
	else if (coord.w == 2)
		shadow = ShadowPCF(_PSSM3_LinearSampler, coord.xy, radius / 4, receiverDepth, rotation, lightSize);
	else
		shadow = ShadowPCF(_PSSM4_LinearSampler, coord.xy, radius / 8, receiverDepth, rotation, lightSize);

	return shadow;
}

float4 ScreenSapceShadowMapFragment(
	in float4 uv : TEXCOORD0,
	in float3 viewdir : TEXCOORD1) : COLOR
{
	float4 MRT5 = tex2Dlod(Gbuffer5Map, float4(uv.xy, 0, 0));
	float4 MRT6 = tex2Dlod(Gbuffer6Map, float4(uv.xy, 0, 0));
	float4 MRT7 = tex2Dlod(Gbuffer7Map, float4(uv.xy, 0, 0));
	float4 MRT8 = tex2Dlod(Gbuffer8Map, float4(uv.xy, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT5, MRT6, MRT7, MRT8, material);

	clip(any(material.visibility) - 1e-5);

	float3 view = normalize(viewdir);
	float3 viewPosition = ComputeViewSpacePosition(uv.xy, SampleLinearEyeDepth(uv.xy));

	return ShadingShadow(material, viewPosition, PseudoRandom(uv.zw) * PI_2);
}

#if SHADOW_BLUR_COUNT
float4 ScreenSapceShadowMapBilateralFilterPS(float2 coord : TEXCOORD0, uniform sampler source, uniform float2 offset) : COLOR
{
	float2 offset1 = coord + offset;
	float2 offset2 = coord - offset;

	float totalWeight = 1;
	float totalColor = tex2Dlod(source, float4(coord, 0, 0)).r;

	float center_d = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0)).r;

	[unroll]
	for(int r = 1; r < SHADOW_BLUR_COUNT; r++)
	{
		float shadow1 = tex2Dlod(source, float4(offset1, 0, 0)).r;
		float shadow2 = tex2Dlod(source, float4(offset2, 0, 0)).r;

		float depth1 = tex2Dlod(Gbuffer8Map, float4(offset1, 0, 0)).r;
		float depth2 = tex2Dlod(Gbuffer8Map, float4(offset2, 0, 0)).r;

		float bilateralWeight1 = BilateralWeight(r, depth1, center_d, SHADOW_BLUR_COUNT, 10);
		float bilateralWeight2 = BilateralWeight(r, depth2, center_d, SHADOW_BLUR_COUNT, 10);

		totalColor += shadow1 * bilateralWeight1;
		totalColor += shadow2 * bilateralWeight2;

		totalWeight += bilateralWeight1;
		totalWeight += bilateralWeight2;

		offset1 += offset;
		offset2 -= offset;
	}

	return totalColor / totalWeight;
}
#endif