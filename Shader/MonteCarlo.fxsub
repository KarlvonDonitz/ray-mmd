// Monte Carlo integration of distributions

// Hammersley Points on the Hemisphere
// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html

float VanDerCorpus(int n, uint base)
{
	float invBase = 1.0 / float(base);
	float denom   = 1.0;
	float result  = 0.0;

	for (int i = 0; i < 32; i++)
	{
		if (n > 0)
		{
			denom   = float(n) % 2.0;
			result += denom * invBase;
			invBase = invBase / 2.0;
			n = uint(float(n) / 2.0);
		}
	}

	return result;
}

float2 HammersleyNoBitOps(uint i, uint samplesCount)
{
	float E1 = (float)i / samplesCount;
	return float2(E1, VanDerCorpus(i, 2u));
}

float3 HammersleySampleCos(float2 Xi)
{
	float phi = 2 * PI * Xi.x;

	float cosTheta = sqrt(Xi.y);
	float sinTheta = sqrt(1 - cosTheta * cosTheta);

	float3 H;
	H.x = sinTheta * cos(phi);
	H.y = sinTheta * sin(phi);
	H.z = cosTheta;

	return H;
}

float3 HammersleySampleGGX(float2 Xi, float roughness)
{
	float m = roughness * roughness;
	float m2 = m * m;
	float u = (1 - Xi.y) / (1 + (m2 - 1) * Xi.y);

	return HammersleySampleCos(float2(Xi.x, u));
}

float4 CosineSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt( E.y );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = CosTheta * (1.0 /  PI);

	return float4( H, PDF );
}

float3 TangentToWorld(float3 N, float3 H)
{
	float3 TangentY = abs(N.z) < 0.999 ? float3(0,0,1) : float3(1,0,0);
	float3 TangentX = normalize(cross(TangentY, N));
	return TangentX * H.x + cross(N, TangentX) * H.y + N * H.z;
}

float3 ImportanceSampleDiffuseIBL(sampler source, float3 N, float3 V, float roughness, int2 random)
{
	const uint NumSamples = 32;

	float3 lighting = 0;

	for (uint i = 0; i < NumSamples; i++)
	{
		float2 E = HammersleyNoBitOps(i, NumSamples);
		float3 L = TangentToWorld(N, HammersleySampleCos(E));
		float3 H = normalize(V + L);

		float nv = saturate(dot(N, V));
		float nl = saturate(dot(N, L));
		float vh = saturate(dot(V, H));

		if (nl > 0.0)
		{
			float3 radiance = tex2Dlod(source, float4(ComputeSphereCoord(L), 0, 0)).rgb;
			
			float energyBias = 0.5 * roughness;
			float energyFactor = lerp(1, 1 / 1.51, roughness);

			float Fd90 = energyBias + 2.0 * vh * vh * roughness;
			float FdV = lerp(1, Fd90, pow5(1 - nv));
			float FdL = lerp(1, Fd90, pow5(1 - nl));

			lighting += radiance * FdV * FdL * energyFactor;
		}
	}

	return lighting / NumSamples;
}

float DistributionGGX(float3 N, float3 H, float roughness)
{
	float a = roughness * roughness;
	float a2 = a*a;
	float NdotH = max(dot(N, H), 0.0);
	float NdotH2 = NdotH*NdotH;

	float nom   = a2;
	float denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom = PI * denom * denom;

	return nom / denom;
}

float3 ImportanceSampleSpecularIBL(sampler source, float3 N, float3 V, float3 f0, float roughness, float resolution)
{
	const uint NumSamples = 32;

	float3 lighting = 0;
	float weight = 0;

	for (uint i = 0; i < NumSamples; i++)
	{
		float2 E = HammersleyNoBitOps(i, NumSamples);
		float3 H = TangentToWorld(N, HammersleySampleGGX(E, roughness));
		float3 L = 2 * dot(V, H) * H - V;

		float nl = saturate(dot(N, L));
		if (nl > 0)
		{
			float nh = saturate(dot(N, H));
			float vh = saturate(dot(V, H));

			float D = DistributionGGX(N, H, roughness);
			float pdf = D * nh / (4.0 * vh) + 0.0001;

			float saTexel = 4.0f * PI / (6.0f * resolution * resolution);
			float saSample = 1.0f / (NumSamples * pdf + 0.00001f);
			float mipLevel = roughness == 0.0f ? 0.0f : 0.5f * log2(saSample / saTexel);

			lighting += tex2Dlod(source, float4(SampleLatlong(L), 0, mipLevel)).rgb * nl;
			weight += nl;
		}
	}

	return lighting / max(0.001f, weight);
}