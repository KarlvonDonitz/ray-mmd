#define CONTACT_SHADOW_SAMPLES 8

float4 ScreenSapceContactShadowFragment(in float4 uv : TEXCOORD0) : COLOR
{
	MaterialParam material = SampleTransparentGbuffer(uv.xy);
	clip(any(material.visibility) - 1e-5);

	float rayLength = max(0.5, 0.01 * material.linearDepth);
	float rayStep = 1.0f / CONTACT_SHADOW_SAMPLES;
	float raySampleTime = rayStep * (1 + InterleavedGradientNoise(uv.zw));

	float3 viewPosition = ComputeViewSpacePosition(uv.xy, material.linearDepth);

	float4 rayStartClip = mul(float4(viewPosition, 1.0f), matProject);
	float4 rayEndClip = mul(float4(viewPosition + mul(-MainLightDirection * rayLength, (float3x3)matView), 1.0f), matProject);

	float4 rayStartScreen = ComputeScreenPos(rayStartClip);
	float4 rayEndScreen = ComputeScreenPos(rayEndClip);

	float4 rayStepScreen = rayEndScreen - rayStartScreen;

	float4 rayDepthClip = rayStartClip + mul(float4(0, 0, rayLength, 0), matProject);

	float firstHitTime = -1.0;
	float compareTolerance = abs(rayDepthClip.w - rayStartClip.w) * rayStep * 2;

	for (uint i = 0; i < CONTACT_SHADOW_SAMPLES; i+=4)
	{
		float4 sampleLength = raySampleTime + float4(0,1,2,3) * rayStep;

		float4 samplePosition[4];
		samplePosition[0] = rayStartScreen + rayStepScreen * sampleLength.x;
		samplePosition[1] = rayStartScreen + rayStepScreen * sampleLength.y;
		samplePosition[2] = rayStartScreen + rayStepScreen * sampleLength.z;
		samplePosition[3] = rayStartScreen + rayStepScreen * sampleLength.w;
		
		float4 sampleDepth;
		sampleDepth.x = SampleLinearEyeDepth(samplePosition[0].xy / samplePosition[0].w + ViewportOffset);
		sampleDepth.y = SampleLinearEyeDepth(samplePosition[1].xy / samplePosition[1].w + ViewportOffset);
		sampleDepth.z = SampleLinearEyeDepth(samplePosition[2].xy / samplePosition[2].w + ViewportOffset);
		sampleDepth.w = SampleLinearEyeDepth(samplePosition[3].xy / samplePosition[3].w + ViewportOffset);

		float4 sampleDepthDiff = sampleDepth - float4(samplePosition[0].w, samplePosition[1].w, samplePosition[2].w, samplePosition[3].w);

		bool4 hit = abs(sampleDepthDiff + compareTolerance) < compareTolerance;
		if (any(hit))
		{
			float hitIndex = 3;
			hitIndex = hit[2] ? 2 : hitIndex;
			hitIndex = hit[1] ? 1 : hitIndex;
			hitIndex = hit[0] ? 0 : hitIndex;

			firstHitTime = raySampleTime + rayStep * hitIndex;
			break;
		}

		raySampleTime += rayStep * 4;
	}

	float2 borderCheck = abs(rayEndScreen.xy / rayEndScreen.w) - 1;

	return (firstHitTime >= 0.0 && borderCheck.x <= 0.0f && borderCheck.y <= 0.0f ? 0.0f : 1.0f);
}