#define DOF_POSSION_SAMPLES 36


// Common DOF
//------------------------------------------------------- DIMENSIONS VALUES.

// Matches C++'s EDiaphragmDOFLayerProcessing
#define LAYER_PROCESSING_FOREGROUND_ONLY 0
#define LAYER_PROCESSING_FOREGROUND_HOLE_FILLING 1
#define LAYER_PROCESSING_BACKGROUND_ONLY 2
#define LAYER_PROCESSING_COMBINED 3
#define LAYER_PROCESSING_SLIGHT_OUT_OF_FOCUS 4


// Matches C++'s EDiaphragmDOFBokehSimulation
#define BOKEH_SIMULATION_DISABLED 0
#define BOKEH_SIMULATION_SIMMETRIC 1
#define BOKEH_SIMULATION_GENERAL 2


//------------------------------------------------------- ENUM VALUES

/** Different hole filling methods. */
	// Hole filling technic that directly changes the foreground opacity. Simplest but hugliest.
	#define HOLE_FILLING_METHOD_OPACITY_AMEND 0
	
	// Use's foreground gathering pass.
	#define HOLE_FILLING_METHOD_SEPARATE_GATHER 1
	
	// TODO IDEA: bilateral sample foreground according to opacity.
	#define HOLE_FILLING_METHOD_BILATERAL 2
	
/** Layout of the input of the gathering passes. */
	// Scene color and CocRadius stored within RGBA buffer 0.
	#define GATHER_INPUT_LAYOUT_RGB_COC 0
	
	// Scene color and alpha stored within RGBA buffer 0, and Coc in buffer 1.
	#define GATHER_INPUT_LAYOUT_RGB_ALPHA_COC 1
	
	// Scene color within RGB_11_11_10 buffer 0, and Coc in buffer 1.
	#define GATHER_INPUT_LAYOUT_RGB_SEPARATE_COC 2


//------------------------------------------------------- COMPILE TIME CONSTANTS.

// A very large Coc radius that is assumed to be unreachable, but still encodable in 16bits float.
#define EXTREMELY_LARGE_COC_RADIUS 16384


// Default border size for group.
#define DEFAULT_GROUP_BORDER_SIZE 8

// Size of the COC in pixel from full screen.
#define COC_TILE_SIZE 8

// The resolution divisor of the current pass
#define PASS_RES_DIVISOR 2

// The resolution devisor that passed as an input of the Coc flatten.
#define COC_TILE_RES_DIVISOR 2

// Number of rings on the main kernel.
#define MAIN_KERNEL_RING_COUNT 5

// Maximum abs(coc radius) the full res recombine pass is going to do.
#define MAX_RECOMBINE_ABS_COC_RADIUS 3.0

/** Width and height of the bokeh LUT. */
#define BOKEH_LUT_SIZE 32

/** Whether alpha channel should be processed or not. */
#define CONFIG_DOF_ALPHA (POST_PROCESS_ALPHA)

/** Amount of error tolerated to quick fast gathering in. */
#define FAST_GATHERING_COC_ERROR 0.05


//------------------------------------------------------- COMPILE TIME CONSTANTS.

// Coc radiuses are in half res.
static const float kCocRadiusToFullResFactor = 0.5;


static const int2 kSquare2x2[4] = {
	int2(0, 0),
	int2(1, 0),
	int2(0, 1),
	int2(1, 1),
};

static const int2 kOffsetsCross3x3[4] = {
	int2(-1, -1),
	int2( 1, -1),
	int2(-1,  1),
	int2( 1,  1),
};

static const int2 kOffsetsSquare3x3[9] = {
	int2(-1, +1),
	int2(-1,  0),
	int2(-1, -1),
	int2( 0, +1),
	int2( 0,  0),
	int2( 0, -1),
	int2(+1, +1),
	int2(+1,  0),
	int2(+1, -1),
};

#define SUBTILE_SIZE DEFAULT_GROUP_BORDER_SIZE

// TILE_SCALE
const static float CocTileScale = 1.0f/COC_TILE_SIZE;

const static int MaxRingCount = 16;
#define KernelSamplingDensityMode 0
#define KERNEL_DENSITY_CONSTANT_HEXAWEB 0
#define KERNEL_DENSITY_LOWER_IN_CENTER_HEXAWEB 1

texture AutoFocalMap : RENDERCOLORTARGET<int2 Dimensions = {1, 1}; string Format="R16F";>;
sampler AutoFocalMapSamp = sampler_state { texture=<AutoFocalMap>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture SetupOutputFull : RENDERCOLORTARGET<float2 ViewportRatio={1.0, 1.0}; string Format="A16B16G16R16F";>;
texture SetupOutputHalf : RENDERCOLORTARGET<float2 ViewportRatio={0.5, 0.5}; string Format="A16B16G16R16F";>;
sampler SetupOutputFullSampler = sampler_state { texture=<SetupOutputFull>; MinFilter=LINEAR; MagFilter=LINEAR; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler SetupOutputHalfSampler = sampler_state { texture=<SetupOutputHalf>; MinFilter=LINEAR; MagFilter=LINEAR; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture TileOutputForeground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
texture TileOutputBackground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
sampler TileOutputForegroundSampler = sampler_state { texture=<TileOutputForeground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler TileOutputBackgroundSampler = sampler_state { texture=<TileOutputBackground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture DilateOutputForeground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
texture DilateOutputBackground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
sampler DilateOutputForegroundSampler = sampler_state { texture=<DilateOutputForeground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler DilateOutputBackgroundSampler = sampler_state { texture=<DilateOutputBackground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture ConvolutionOutputSceneColor : RENDERCOLORTARGET<float2 ViewportRatio={1, 1}; string Format="A16B16G16R16F";>;
texture ConvolutionOutputSeparateAlpha : RENDERCOLORTARGET<float2 ViewportRatio={1, 1}; string Format="A16B16G16R16F";>;
sampler ConvolutionOutputSceneColorSampler = sampler_state { texture=<ConvolutionOutputSceneColor>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler ConvolutionOutputSeparateAlphaSampler = sampler_state { texture=<ConvolutionOutputSeparateAlpha>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

float GetCameraFOV()
{
    float t = matProject._m11;
    float Rad2Deg = 180 / 3.1415;
    float fov = atan(t) * 2.0 * Rad2Deg;
    return fov;
}

float GetSampleRadius()
{
	return 0.2;
}

float2 GetSamplePoint()
{
	float4 proj = mul(float4(AcsPosition, 1), matViewProject);
	proj /= proj.w;
	proj.xy = PosToCoord(proj.xy);
	return 0.5 + float2(proj.x - 0.5, 0.0) * step(0.25, mMeasureMode);
}

float GetFocalDistance()
{
	float focalDistance = mFocalDistance + (distance(CameraPosition, AcsPosition) - 1) * step(0.99, mMeasureMode);
	return max(1, focalDistance);
}

float GetFocalAperture(float Fstop)
{
	float aperture = 1.0 / Fstop;
	return aperture;
}

float GetFocalLength(float mFocalLength, float focalDistance)
{
	return 1.0 / (1.0 / (0.5 * mFocalLength * matProject._22) + 1.0 / focalDistance);
}

float4 ComputeFocalDistancePS(in float2 coord : TEXCOORD0, uniform sampler source) : COLOR
{
	static const float2 poisson[DOF_POSSION_SAMPLES] =
	{
		float2(-1.0,  0.0), float2(-2.0,  0.0), float2(-3.0,  0.0), float2(3.0,  0.0), float2(2.0,  0.0), float2(1.0,  0.0),
		float2(-1.0, -1.0), float2(-2.0, -1.0),	float2(-3.0, -1.0), float2(0.0, -1.0), float2(3.0, -1.0), float2(2.0, -1.0), float2(1.0, -1.0),
		float2(-1.0,  1.0), float2(-2.0,  1.0), float2(-3.0,  1.0), float2(0.0,  1.0), float2(3.0,  1.0), float2(2.0,  1.0), float2(1.0,  1.0),
		float2(-2.0,  2.0), float2(-1.0,  2.0), float2( 0.0,  2.0), float2(1.0,  2.0), float2(2.0,  2.0),
		float2(-2.0, -2.0), float2(-1.0, -2.0), float2( 0.0, -2.0), float2(1.0, -2.0), float2(2.0, -2.0),
		float2(-1.0,  3.0), float2( 0.0,  3.0), float2( 1.0,  3.0),
		float2(-1.0, -3.0), float2( 0.0, -3.0), float2( 1.0, -3.0),
	};

	const float2 sampleRadius = GetSampleRadius() / float2(ViewportAspect * 3, 3.0);
	const float2 samplePoint = GetSamplePoint();

	float minDepth = 65535;

	[loop]
	for (int i = 0; i < DOF_POSSION_SAMPLES; i++)
	{
		float depth = tex2Dlod(Gbuffer8Map, float4(samplePoint + poisson[i] * sampleRadius, 0, 0)).r;
		minDepth = min(minDepth, depth);
	}

	float2 avgDepth = 0;

	[loop]
	for (int j = 0; j < DOF_POSSION_SAMPLES; j++)
	{
		float depth = tex2Dlod(Gbuffer8Map, float4(samplePoint + poisson[j] * sampleRadius, 0, 0)).r;
		avgDepth += float2(depth, 1) * exp2(-abs(depth - minDepth));
	}

	float distance = avgDepth.x / avgDepth.y;
	return lerp(distance + mFocalDistance - 1, GetFocalDistance(), step(0.5, mMeasureMode));
}

float ComputeDepthCoC(float depth, float4 focalParams)
{
	float D = depth;
	float P = focalParams.x; // focalDistance
	float F = focalParams.y / 1000.0f; // focalLength
	float A = focalParams.y / focalParams.z; // focalAperture
	float focalRegion = focalParams.w;

	// Calculate circle of confusion diameter
	// http://en.wikipedia.org/wiki/Circle_of_confusion
	float CoC = A * (max(abs(D - P) - focalParams.w, 0) / D) * (F / (P - F));

	float sensorHeight = mSensorHeight * 0.001f;

	// put CoC into a % of the image sensor height
	float percentOfSensor = CoC / sensorHeight * sign(D - P);

	return clamp(percentOfSensor, -1.0, 1.0);
}

// Return whether this is front element from CocRadius.
bool IsForeground(float CocRadius)
{
	return CocRadius < 0.0f;
}

// Faster but less accurate luma computation with a scaling by 4.
float Luma4(float3 Color)
{
	return (Color.g * 2.0) + (Color.r + Color.b);
}

// Returns 1/x if x > 0, d otherwise.
float SafeRcp(float x, float d = 0.0)
{
	return x > 0.0 ? rcp(x) : d;
}

// Converts a distance in full res pixel to coc distance.
#define FullResPixelDistanceToCocDistance(x) (0.5 * (x))

// Converts a distance in full res pixel to coc distance.
#define CocDistanceToFullResPixelDistance(x) (2.0 * (x))

// Utility to use a saturating affine transformation.
float SaturateWithAffineTransformation(float x, float2 AffineTransformation)
{
	// Hint: Just one MAD with saturate post modifier on GCN.
	return saturate(x * AffineTransformation.x + AffineTransformation.y);
}

// Affine transformtations that always return 0 or 1.
#define kContantlyPassingAffineTransformation float2(0, 1)
#define kContantlyBlockingAffineTransformation float2(0, 0)


float4 DOFSetupFullVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = tex2Dlod(AutoFocalMapSamp, float4(0.5,0.5, 0, 0)).r;
    float4 focalCameraParams = float4(focalDistance, GetCameraFocalLength(mSensorWidth), mFstop, mFocalRegion);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += ViewportOffset;
	oTexcoord1 = focalCameraParams;

	return Position;
}

float4 DOFSetupFullPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    uniform sampler source) : COLOR
{
	float3 sceneColor = min(tex2Dlod(source, float4(coord, 0, 0)).rgb, float3(65535, 65535, 65535));
	float deviceZ = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0)).r;
	float focalDistance = tex2Dlod(AutoFocalMapSamp, float4(0.5,0.5, 0, 0)).r;
	float cocRadius = ComputeDepthCoC(deviceZ, focalCameraParams);

	// Output full resolution.
	return float4(sceneColor, cocRadius);
}



/** Operator to use to downsample 4 sample to 1. */
// TODO: This as been fetched from Circle DOF, so redo this experiments, and try new ones.
float DownsampleCoc(float CocRadii[4])
{
	// Doing a max depth reduction (erode the foreground). Less correct, but less artifacts.
	// Perhaps need to re-open this in the future.
	float mi = min(min(CocRadii[0], CocRadii[1]), min(CocRadii[2], CocRadii[3]));
	float ma = max(max(CocRadii[0], CocRadii[1]), max(CocRadii[2], CocRadii[3]));
	float ami = min(min(abs(CocRadii[0]), abs(CocRadii[1])), min(abs(CocRadii[2]), abs(CocRadii[3])));
	float ama = max(max(abs(CocRadii[0]), abs(CocRadii[1])), max(abs(CocRadii[2]), abs(CocRadii[3])));

	// This in theory is better but causes bleeding artifacts with temporal AA..
	// This is important otherwise near thin objects disappear (leaves clamping artifacts in recombined pass).
	// bad on TemporalDitherAA, flat opacity where it should transition
	float OutCocRadius = CocRadii[0];
	if(abs(OutCocRadius) > CocRadii[1]) OutCocRadius = CocRadii[1];
	if(abs(OutCocRadius) > CocRadii[2]) OutCocRadius = CocRadii[2];
	if(abs(OutCocRadius) > CocRadii[3]) OutCocRadius = CocRadii[3];

	return OutCocRadius;
}

/** Compute the bilateral weight of sample to downsample. */
float ComputeDownsamplingBilateralWeight(
	float OutCocRadius,
	float SampleCocRadius,
	float3 SampleColor = 0)
{
	// Remove samples which are outside the size.
	// TODO: Tune the ScaleFactor. Looks like to large.
	float ScaleFactor = 64.0;

	// not doing abs(OutCocRadius - SampleCocRadius) because: it is fine to leak background on foreground arround geometric
	// edges because going to be close to the hole filling as well. This allow dither opacity material such as dithered human hair
	// to keep consistent opacity, thickness, and temporal stability as the Coc changes between slight out focus, foreground
	// and background.
	#if 1
		float BilateralWeight = saturate(1.0 - (OutCocRadius - SampleCocRadius) * ScaleFactor);
	#else
		// GCN Hint: one subtract with abs() post modifier + one MAD with saturate post modifier.
		float BilateralWeight = saturate(1.0 - abs(OutCocRadius - SampleCocRadius) * ScaleFactor);
	#endif
	
	float ColorWeight = 1;

	return BilateralWeight * ColorWeight;
}

float4 DOFSetupHalfVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * 0.5);
	oTexcoord1 = focalCameraParams;
	return Position;
}

float4 DOFSetupHalfPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    uniform sampler source) : COLOR
{
	float4 samples[4];

	samples[0] = tex2Dlod(SetupOutputFullSampler, float4(coord, 0, 0));
	samples[1] = tex2Dlod(SetupOutputFullSampler, float4(coord + float2(ViewportOffset2.x, 0), 0, 0));
	samples[2] = tex2Dlod(SetupOutputFullSampler, float4(coord + float2(0, ViewportOffset2.y), 0, 0));
	samples[3] = tex2Dlod(SetupOutputFullSampler, float4(coord + ViewportOffset2, 0, 0));

	// Choose the best the coc to use.
	float cocs[4];
	cocs[0] = samples[0].a;
	cocs[1] = samples[1].a;
	cocs[2] = samples[2].a;
	cocs[3] = samples[3].a;
	float outCocRadius = DownsampleCoc(cocs);

	float4 BilateralWeights = float4(
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[0], samples[0].rgb),
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[1], samples[1].rgb),
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[2], samples[2].rgb),
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[3], samples[3].rgb));

	float WeightSum = dot(float4(1, 1, 1, 1), BilateralWeights);

	// Normalize weights.
	float WeightNormalizationFactor = rcp(WeightSum);

	// Do the multiply of WeightNormalizationFactor, because save one mad when alpha channel is disabled.
	float4 outColor = WeightNormalizationFactor * (
		samples[0] * BilateralWeights.x +
		samples[1] * BilateralWeights.y +
		samples[2] * BilateralWeights.z +
		samples[3] * BilateralWeights.w);

	return float4(outColor.rgb, outCocRadius);
}


float4 CocFlattenMainVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * CocTileScale);
	oTexcoord1 = focalCameraParams;
	return Position;
}

void CocFlattenMainPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    out float4 foreground : COLOR0,
    out float4 background : COLOR1)
{
    float minFgdCoc, minBgdCoc = 25565;
    float maxFgdCoc, maxBgdCoc = -25565;
    
    for (int i = 0; i < 4; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            float4 colorCoc = tex2Dlod(SetupOutputHalfSampler, float4(coord + float2(i, j) * ViewportOffset2, 0, 0));
            float coc = colorCoc.a;
            if (coc > 1e-4)
            {
                if (coc > maxBgdCoc) maxBgdCoc = coc;
                if (coc < minBgdCoc) minBgdCoc = coc;
            }
            else if (coc < -1e-4)
            {
                if (coc > maxFgdCoc) maxFgdCoc = coc;
                if (coc < minFgdCoc) minFgdCoc = coc;
            }
        }
    }
    foreground = float4(clamp(minFgdCoc, -1, 0), clamp(maxFgdCoc, -1, 0), 0, 0);
    background = float4(clamp(minBgdCoc, 0, 1), clamp(maxBgdCoc, 0, 1), 0, 0);
}


float4 CocDilateMainVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * CocTileScale);
	oTexcoord1 = focalCameraParams;
	return Position;
}

void CocDilateMainPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    out float4 foreground : COLOR0,
    out float4 background : COLOR1)
{
    foreground = tex2Dlod(TileOutputForegroundSampler, float4(coord, 0, 0));
    background = tex2Dlod(TileOutputBackgroundSampler, float4(coord, 0, 0));
}

float4 GatherMainVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * CocTileScale);
	oTexcoord1 = focalCameraParams;
	return Position;
}

// Returns the total number of sampling iteration for a given ring id.
int GetRingSamplingPairCount(int RingId)
{
#if KernelSamplingDensityMode == KERNEL_DENSITY_CONSTANT_HEXAWEB || KernelSamplingDensityMode == KERNEL_DENSITY_LOWER_IN_CENTER_HEXAWEB
    return (RingId + 1) * 3;
#else
    // This number of sample is carefully chosen to have exact number of sample a square shaped ring (SquarePos).
    return (RingId + 1) * 4;
#endif
}


// Returns the total number of sample of the kernel.
int GetKernelSampleCount(int RingCount)
{
#if KernelSamplingDensityMode == KERNEL_DENSITY_CONSTANT_HEXAWEB || KernelSamplingDensityMode == KERNEL_DENSITY_LOWER_IN_CENTER_HEXAWEB
    return 1 + 3 * RingCount * (RingCount + 1);
#else
	// Depends on GetRingSamplingPairCount().
	return 1 + 4 * RingCount * (RingCount + 1);
#endif
}

// Returns the position of the sample on the unit circle (radius = 1) for a given ring.
float2 GetDiskSampleOnUnitCirle(int RingId, int RingSampleIteration, int RingSampleId)
{
	float SampleRingPos = RingSampleId;

	// Do not allign all j == 0 samples of the different ring on the X axis to increase minimal distance between all
	// samples, that reduce variance to clean by post filtering.
	SampleRingPos += (RingId - 2 * (RingId / 2)) * 0.5;

	// #if CONFIG_SLIGHT_RING_ROTATION
	// 	SampleRingPos += (RingId + 1) * 0.2;
	// #endif

	float SampleAngle = PI * SampleRingPos / float(RingSampleIteration);
			
	return float2(cos(SampleAngle), sin(SampleAngle));
}

// Returns the rotation matrix to use between sample of the ring.
float2x2 GetSampleRotationMatrix(int RingSampleIteration)
{
	float RotationAngle = 2 * PI / float(RingSampleIteration);

	float C = cos(RotationAngle);
	float S = sin(RotationAngle);

	return float2x2(
		float2( C,  S),
		float2(-S,  C));
}

float4 GatherRingSamples(float2 coord, int RingId, int RingCount)
{
    float4 cumcolor = 0;
    float cumweight = 0;

    float centerCoC = tex2Dlod(SetupOutputHalfSampler, float4(coord, 0, 0)).a;

    // Radius of a sample in the unit circle.
	const float UnitSampleRadius = rcp(RingCount + 0.5);

    const float KernelRadius = 16;

    float SampleCountToSamplePosition = KernelRadius * UnitSampleRadius;

    // Number of sample iteration for this ring.
    const int RingSamplePairCount = GetRingSamplingPairCount(RingId);

    // Number of batch to process.
    const int BatchCount = RingSamplePairCount;

    // Distance of the ring from the center of the kernel in sample count.
    const int RingDistance = RingId + 1;

    float RingRadius = RingDistance * SampleCountToSamplePosition;

    // Generate at compile time sample rotation matrix.
    const float2x2 SampleRotationMatrix = GetSampleRotationMatrix(RingSamplePairCount);

    // Generates at compile time first sample location on circle (radius = 1).
    const float2 FirstCircleUnitPos = GetDiskSampleOnUnitCirle(RingId, RingSamplePairCount, /* BatchId = */ 0);

    // Position of the first sample on circle with radius according to KernelRadius.
    float2 FirstCircleSamplePosOffset = FirstCircleUnitPos * RingRadius;

    // Setup iteratable SGPR
    float2 CurrentCircleUnitPos = FirstCircleUnitPos;
    float2 CurrentCircleSamplePosOffset = FirstCircleSamplePosOffset;

    for (int BatchId = 0; BatchId < BatchCount; BatchId++)
    {
        CurrentCircleUnitPos = mul(CurrentCircleUnitPos, SampleRotationMatrix);
        CurrentCircleSamplePosOffset = mul(CurrentCircleSamplePosOffset, SampleRotationMatrix);

        // Swizzle the batch positions' X and Y components.
        float2 CirleUnitPos = CurrentCircleUnitPos;
        float2 CircleSamplePosOffset = CurrentCircleSamplePosOffset;

        float2 SamplePos = coord + CircleSamplePosOffset * ViewportOffset2;
        float backWeight = tex2Dlod(DilateOutputBackgroundSampler, float4(SamplePos, 0, 0)).g;
        float foreWeight = -tex2Dlod(DilateOutputForegroundSampler, float4(SamplePos, 0, 0)).r;
        float weight = max(backWeight, foreWeight);
        float4 color = tex2Dlod(SetupOutputFullSampler, float4(SamplePos, 0, 0));
        if (min(backWeight, foreWeight) < centerCoC && weight * ViewportSize.x >= RingRadius) {
            cumcolor += weight * color;
            cumweight += weight;
        }
    }

    if (cumweight < 1e-6) {
        return tex2Dlod(SetupOutputFullSampler, float4(coord, 0, 0));
    } else {
        return cumcolor / cumweight;
    }
}

float4 GatherRing(float2 coord, int RingId)
{
    float4 color = 0;
    // Number of sample iteration for this ring.
    const int RingSamplePairCount = GetRingSamplingPairCount(RingId);
	// Distance of the ring from the center of the kernel in sample count.
	const int RingDistance = int(RingId + 1);

    // Start accumulating ring samples
	// StartRingSamples(Accumulator, RingInfos);

	color += GatherRingSamples(coord, RingId, MaxRingCount);
	
	// End accumulating ring samples.
	// EndRingSamples(Accumulator, RingInfos);
    return color;
}

void GatherMainPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    out float4 sceneColor : COLOR0,
    out float4 separateAlpha : COLOR1)
{
    sceneColor = 0;
    separateAlpha = 0;
    // Sample Coc tile texture.
    for (int RingId = MaxRingCount - 1; RingId >= 0; RingId--)
    {
        sceneColor += GatherRing(coord, int(RingId));
    }

    sceneColor /= float(MaxRingCount);
}

float4 DOFOutputVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += ViewportOffset;
	oTexcoord1 = focalCameraParams;
	return Position;
}

float4 DOFOutputPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    uniform sampler source): COLOR
{
	// float3 color = tex2Dlod(SetupOutputHalfSampler, float4(coord, 0, 0)).rgb;
	// float coc = tex2Dlod(SetupOutputHalfSampler, float4(coord, 0, 0)).a / 10;
	// return float4(coc, coc, coc, 1.0);

	// float2 minMaxBgdCoc = tex2Dlod(DilateOutputBackgroundSampler, float4(coord, 0, 0)).rg / 10;
    // float2 minMaxFgdCoc = tex2Dlod(DilateOutputForegroundSampler, float4(coord, 0, 0)).rg / 10;
	// return float4(abs(minMaxFgdCoc.r), minMaxBgdCoc.g, 0.0, 1.0);
    float4 color = tex2Dlod(ConvolutionOutputSceneColorSampler, float4(coord, 0, 0));
    return float4(color.r, color.g, color.b, 1.0);
}

