#define DOF_POSSION_SAMPLES 36


// Common DOF
//------------------------------------------------------- DIMENSIONS VALUES.

// Matches C++'s EDiaphragmDOFLayerProcessing
#define LAYER_PROCESSING_FOREGROUND_ONLY 0
#define LAYER_PROCESSING_FOREGROUND_HOLE_FILLING 1
#define LAYER_PROCESSING_BACKGROUND_ONLY 2
#define LAYER_PROCESSING_COMBINED 3
#define LAYER_PROCESSING_SLIGHT_OUT_OF_FOCUS 4


// Matches C++'s EDiaphragmDOFBokehSimulation
#define BOKEH_SIMULATION_DISABLED 0
#define BOKEH_SIMULATION_SIMMETRIC 1
#define BOKEH_SIMULATION_GENERAL 2


//------------------------------------------------------- ENUM VALUES

/** Different hole filling methods. */
	// Hole filling technic that directly changes the foreground opacity. Simplest but hugliest.
	#define HOLE_FILLING_METHOD_OPACITY_AMEND 0
	
	// Use's foreground gathering pass.
	#define HOLE_FILLING_METHOD_SEPARATE_GATHER 1
	
	// TODO IDEA: bilateral sample foreground according to opacity.
	#define HOLE_FILLING_METHOD_BILATERAL 2
	
/** Layout of the input of the gathering passes. */
	// Scene color and CocRadius stored within RGBA buffer 0.
	#define GATHER_INPUT_LAYOUT_RGB_COC 0
	
	// Scene color and alpha stored within RGBA buffer 0, and Coc in buffer 1.
	#define GATHER_INPUT_LAYOUT_RGB_ALPHA_COC 1
	
	// Scene color within RGB_11_11_10 buffer 0, and Coc in buffer 1.
	#define GATHER_INPUT_LAYOUT_RGB_SEPARATE_COC 2


//------------------------------------------------------- COMPILE TIME CONSTANTS.

// A very large Coc radius that is assumed to be unreachable, but still encodable in 16bits float.
#define EXTREMELY_LARGE_COC_RADIUS 16384


// Default border size for group.
#define DEFAULT_GROUP_BORDER_SIZE 8

// Size of the COC in pixel from full screen.
#define COC_TILE_SIZE 8

// The resolution divisor of the current pass
#define PASS_RES_DIVISOR 2

// The resolution devisor that passed as an input of the Coc flatten.
#define COC_TILE_RES_DIVISOR 2

// Number of rings on the main kernel.
#define MAIN_KERNEL_RING_COUNT 5

// Maximum abs(coc radius) the full res recombine pass is going to do.
#define MAX_RECOMBINE_ABS_COC_RADIUS 3.0

/** Width and height of the bokeh LUT. */
#define BOKEH_LUT_SIZE 32

/** Whether alpha channel should be processed or not. */
#define CONFIG_DOF_ALPHA (POST_PROCESS_ALPHA)

/** Amount of error tolerated to quick fast gathering in. */
#define FAST_GATHERING_COC_ERROR 0.05


//------------------------------------------------------- COMPILE TIME CONSTANTS.

// Coc radiuses are in half res.
static const float kCocRadiusToFullResFactor = 0.5;


static const int2 kSquare2x2[4] = {
	int2(0, 0),
	int2(1, 0),
	int2(0, 1),
	int2(1, 1),
};

static const int2 kOffsetsCross3x3[4] = {
	int2(-1, -1),
	int2( 1, -1),
	int2(-1,  1),
	int2( 1,  1),
};

static const int2 kOffsetsSquare3x3[9] = {
	int2(-1, +1),
	int2(-1,  0),
	int2(-1, -1),
	int2( 0, +1),
	int2( 0,  0),
	int2( 0, -1),
	int2(+1, +1),
	int2(+1,  0),
	int2(+1, -1),
};

#define SUBTILE_SIZE DEFAULT_GROUP_BORDER_SIZE

// TILE_SCALE
const static float CocTileScale = 1.0f/COC_TILE_SIZE;

const static int MaxRingCount = 12;
const static float KernelRadius = 32 * ViewportOffset2;
const static int CocRadiusError = 1;
#define KernelSamplingDensityMode 0
#define KERNEL_DENSITY_CONSTANT_HEXAWEB 0
#define KERNEL_DENSITY_LOWER_IN_CENTER_HEXAWEB 1

texture AutoFocalMap : RENDERCOLORTARGET<int2 Dimensions = {1, 1}; string Format="R16F";>;
sampler AutoFocalMapSamp = sampler_state { texture=<AutoFocalMap>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture SetupOutputFull : RENDERCOLORTARGET<float2 ViewportRatio={1.0, 1.0}; string Format="A16B16G16R16F";>;
texture SetupOutputHalf : RENDERCOLORTARGET<float2 ViewportRatio={0.5, 0.5}; string Format="A16B16G16R16F";>;
sampler SetupOutputFullSampler = sampler_state { texture=<SetupOutputFull>; MinFilter=LINEAR; MagFilter=LINEAR; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler SetupOutputHalfSampler = sampler_state { texture=<SetupOutputHalf>; MinFilter=LINEAR; MagFilter=LINEAR; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture TileOutputForeground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
texture TileOutputBackground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
sampler TileOutputForegroundSampler = sampler_state { texture=<TileOutputForeground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler TileOutputBackgroundSampler = sampler_state { texture=<TileOutputBackground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture DilateOutputForeground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
texture DilateOutputBackground : RENDERCOLORTARGET<float2 ViewportRatio={0.125, 0.125}; string Format="A16B16G16R16F";>;
sampler DilateOutputForegroundSampler = sampler_state { texture=<DilateOutputForeground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler DilateOutputBackgroundSampler = sampler_state { texture=<DilateOutputBackground>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

texture ConvolutionOutputSceneColor : RENDERCOLORTARGET<float2 ViewportRatio={1, 1}; string Format="A16B16G16R16F";>;
texture ConvolutionOutputSeparateAlpha : RENDERCOLORTARGET<float2 ViewportRatio={1, 1}; string Format="A16B16G16R16F";>;
sampler ConvolutionOutputSceneColorSampler = sampler_state { texture=<ConvolutionOutputSceneColor>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };
sampler ConvolutionOutputSeparateAlphaSampler = sampler_state { texture=<ConvolutionOutputSeparateAlpha>; MinFilter=POINT; MagFilter=POINT; MipFilter=NONE; AddressU=CLAMP; AddressV=CLAMP; };

float GetCameraFOV()
{
    float t = matProject._m11;
    float Rad2Deg = 180 / 3.1415;
    float fov = atan(t) * 2.0 * Rad2Deg;
    return fov;
}

float GetSampleRadius()
{
	return 0.2;
}

float2 GetSamplePoint()
{
	float4 proj = mul(float4(AcsPosition, 1), matViewProject);
	proj /= proj.w;
	proj.xy = PosToCoord(proj.xy);
	return 0.5 + float2(proj.x - 0.5, 0.0) * step(0.25, mMeasureMode);
}

float GetFocalDistance()
{
	float focalDistance = mFocalDistance + (distance(CameraPosition, AcsPosition) - 1) * step(0.99, mMeasureMode);
	return max(1, focalDistance);
}

float GetFocalAperture(float Fstop)
{
	float aperture = 1.0 / Fstop;
	return aperture;
}

float GetFocalLength(float mFocalLength, float focalDistance)
{
	return 1.0 / (1.0 / (0.5 * mFocalLength * matProject._22) + 1.0 / focalDistance);
}

float4 ComputeFocalDistancePS(in float2 coord : TEXCOORD0, uniform sampler source) : COLOR
{
	static const float2 poisson[DOF_POSSION_SAMPLES] =
	{
		float2(-1.0,  0.0), float2(-2.0,  0.0), float2(-3.0,  0.0), float2(3.0,  0.0), float2(2.0,  0.0), float2(1.0,  0.0),
		float2(-1.0, -1.0), float2(-2.0, -1.0),	float2(-3.0, -1.0), float2(0.0, -1.0), float2(3.0, -1.0), float2(2.0, -1.0), float2(1.0, -1.0),
		float2(-1.0,  1.0), float2(-2.0,  1.0), float2(-3.0,  1.0), float2(0.0,  1.0), float2(3.0,  1.0), float2(2.0,  1.0), float2(1.0,  1.0),
		float2(-2.0,  2.0), float2(-1.0,  2.0), float2( 0.0,  2.0), float2(1.0,  2.0), float2(2.0,  2.0),
		float2(-2.0, -2.0), float2(-1.0, -2.0), float2( 0.0, -2.0), float2(1.0, -2.0), float2(2.0, -2.0),
		float2(-1.0,  3.0), float2( 0.0,  3.0), float2( 1.0,  3.0),
		float2(-1.0, -3.0), float2( 0.0, -3.0), float2( 1.0, -3.0),
	};

	const float2 sampleRadius = GetSampleRadius() / float2(ViewportAspect * 3, 3.0);
	const float2 samplePoint = GetSamplePoint();

	float minDepth = 65535;

	[loop]
	for (int i = 0; i < DOF_POSSION_SAMPLES; i++)
	{
		float depth = tex2Dlod(Gbuffer8Map, float4(samplePoint + poisson[i] * sampleRadius, 0, 0)).r;
		minDepth = min(minDepth, depth);
	}

	float2 avgDepth = 0;

	[loop]
	for (int j = 0; j < DOF_POSSION_SAMPLES; j++)
	{
		float depth = tex2Dlod(Gbuffer8Map, float4(samplePoint + poisson[j] * sampleRadius, 0, 0)).r;
		avgDepth += float2(depth, 1) * exp2(-abs(depth - minDepth));
	}

	float distance = avgDepth.x / avgDepth.y;
	return lerp(distance + mFocalDistance - 1, GetFocalDistance(), step(0.5, mMeasureMode));
}

float ComputeDepthCoC(float depth, float4 focalParams)
{
	float D = depth;
	float P = focalParams.x; // focalDistance
	float F = focalParams.y / 1000.0f; // focalLength
	float A = focalParams.y / focalParams.z; // focalAperture
	float focalRegion = focalParams.w;

	// Calculate circle of confusion diameter
	// http://en.wikipedia.org/wiki/Circle_of_confusion
	float CoC = A * (max(abs(D - P) - focalParams.w, 0) / D) * (F / (P - F));

	float sensorHeight = mSensorHeight * 0.001f;

	// put CoC into a % of the image sensor height
	float percentOfSensor = CoC / sensorHeight * sign(D - P);

	return clamp(percentOfSensor, -1.0, 1.0);
}

// Return whether this is front element from CocRadius.
bool IsForeground(float CocRadius)
{
	return CocRadius < 0.0f;
}

// Faster but less accurate luma computation with a scaling by 4.
float Luma4(float3 Color)
{
	return (Color.g * 2.0) + (Color.r + Color.b);
}

// Returns 1/x if x > 0, d otherwise.
float SafeRcp(float x, float d = 0.0)
{
	return x > 0.0 ? rcp(x) : d;
}

// Converts a distance in full res pixel to coc distance.
#define FullResPixelDistanceToCocDistance(x) (0.5 * (x))

// Converts a distance in full res pixel to coc distance.
#define CocDistanceToFullResPixelDistance(x) (2.0 * (x))

// Utility to use a saturating affine transformation.
float SaturateWithAffineTransformation(float x, float2 AffineTransformation)
{
	// Hint: Just one MAD with saturate post modifier on GCN.
	return saturate(x * AffineTransformation.x + AffineTransformation.y);
}

// Affine transformtations that always return 0 or 1.
#define kContantlyPassingAffineTransformation float2(0, 1)
#define kContantlyBlockingAffineTransformation float2(0, 0)


float4 DOFSetupFullVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = tex2Dlod(AutoFocalMapSamp, float4(0.5,0.5, 0, 0)).r;
    float4 focalCameraParams = float4(focalDistance, GetCameraFocalLength(mSensorWidth), mFstop, mFocalRegion);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += ViewportOffset;
	oTexcoord1 = focalCameraParams;

	return Position;
}

float4 DOFSetupFullPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    uniform sampler source) : COLOR
{
	float3 sceneColor = min(tex2Dlod(source, float4(coord, 0, 0)).rgb, float3(65535, 65535, 65535));
	float deviceZ = tex2Dlod(Gbuffer8Map, float4(coord, 0, 0)).r;
	float focalDistance = tex2Dlod(AutoFocalMapSamp, float4(0.5,0.5, 0, 0)).r;
	float cocRadius = ComputeDepthCoC(deviceZ, focalCameraParams);

	// Output full resolution.
	return float4(sceneColor, cocRadius);
}



/** Operator to use to downsample 4 sample to 1. */
// TODO: This as been fetched from Circle DOF, so redo this experiments, and try new ones.
float DownsampleCoc(float CocRadii[4])
{
	// Doing a max depth reduction (erode the foreground). Less correct, but less artifacts.
	// Perhaps need to re-open this in the future.
	float mi = min(min(CocRadii[0], CocRadii[1]), min(CocRadii[2], CocRadii[3]));
	float ma = max(max(CocRadii[0], CocRadii[1]), max(CocRadii[2], CocRadii[3]));
	float ami = min(min(abs(CocRadii[0]), abs(CocRadii[1])), min(abs(CocRadii[2]), abs(CocRadii[3])));
	float ama = max(max(abs(CocRadii[0]), abs(CocRadii[1])), max(abs(CocRadii[2]), abs(CocRadii[3])));

	// This in theory is better but causes bleeding artifacts with temporal AA..
	// This is important otherwise near thin objects disappear (leaves clamping artifacts in recombined pass).
	// bad on TemporalDitherAA, flat opacity where it should transition
	float OutCocRadius = CocRadii[0];
	if(abs(OutCocRadius) > CocRadii[1]) OutCocRadius = CocRadii[1];
	if(abs(OutCocRadius) > CocRadii[2]) OutCocRadius = CocRadii[2];
	if(abs(OutCocRadius) > CocRadii[3]) OutCocRadius = CocRadii[3];

	return OutCocRadius;
}

/** Compute the bilateral weight of sample to downsample. */
float ComputeDownsamplingBilateralWeight(
	float OutCocRadius,
	float SampleCocRadius,
	float3 SampleColor = 0)
{
	// Remove samples which are outside the size.
	// TODO: Tune the ScaleFactor. Looks like to large.
	float ScaleFactor = 64.0;

	// not doing abs(OutCocRadius - SampleCocRadius) because: it is fine to leak background on foreground arround geometric
	// edges because going to be close to the hole filling as well. This allow dither opacity material such as dithered human hair
	// to keep consistent opacity, thickness, and temporal stability as the Coc changes between slight out focus, foreground
	// and background.
	#if 1
		float BilateralWeight = saturate(1.0 - (OutCocRadius - SampleCocRadius) * ScaleFactor);
	#else
		// GCN Hint: one subtract with abs() post modifier + one MAD with saturate post modifier.
		float BilateralWeight = saturate(1.0 - abs(OutCocRadius - SampleCocRadius) * ScaleFactor);
	#endif
	
	float ColorWeight = 1;

	return BilateralWeight * ColorWeight;
}

float4 DOFSetupHalfVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * 0.5);
	oTexcoord1 = focalCameraParams;
	return Position;
}

float4 DOFSetupHalfPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    uniform sampler source) : COLOR
{
	float4 samples[4];

	samples[0] = tex2Dlod(SetupOutputFullSampler, float4(coord, 0, 0));
	samples[1] = tex2Dlod(SetupOutputFullSampler, float4(coord + float2(ViewportOffset2.x, 0), 0, 0));
	samples[2] = tex2Dlod(SetupOutputFullSampler, float4(coord + float2(0, ViewportOffset2.y), 0, 0));
	samples[3] = tex2Dlod(SetupOutputFullSampler, float4(coord + ViewportOffset2, 0, 0));

	// Choose the best the coc to use.
	float cocs[4];
	cocs[0] = samples[0].a;
	cocs[1] = samples[1].a;
	cocs[2] = samples[2].a;
	cocs[3] = samples[3].a;
	float outCocRadius = DownsampleCoc(cocs);

	float4 BilateralWeights = float4(
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[0], samples[0].rgb),
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[1], samples[1].rgb),
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[2], samples[2].rgb),
		ComputeDownsamplingBilateralWeight(outCocRadius, cocs[3], samples[3].rgb));

	float WeightSum = dot(float4(1, 1, 1, 1), BilateralWeights);

	// Normalize weights.
	float WeightNormalizationFactor = rcp(WeightSum);

	// Do the multiply of WeightNormalizationFactor, because save one mad when alpha channel is disabled.
	float4 outColor = WeightNormalizationFactor * (
		samples[0] * BilateralWeights.x +
		samples[1] * BilateralWeights.y +
		samples[2] * BilateralWeights.z +
		samples[3] * BilateralWeights.w);

	return float4(outColor.rgb, outCocRadius);
}


float4 CocFlattenMainVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * CocTileScale);
	oTexcoord1 = focalCameraParams;
	return Position;
}

void CocFlattenMainPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    out float4 foreground : COLOR0,
    out float4 background : COLOR1)
{
    float minFgdCoc, minBgdCoc = 25565;
    float maxFgdCoc, maxBgdCoc = -25565;
    
    for (int i = 0; i < 4; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            float4 colorCoc = tex2Dlod(SetupOutputHalfSampler, float4(coord + float2(i, j) * ViewportOffset2, 0, 0));
            float coc = colorCoc.a;
            if (coc > 1e-4)
            {
                if (coc > maxBgdCoc) maxBgdCoc = coc;
                if (coc < minBgdCoc) minBgdCoc = coc;
            }
            else if (coc < -1e-4)
            {
                if (coc > maxFgdCoc) maxFgdCoc = coc;
                if (coc < minFgdCoc) minFgdCoc = coc;
            }
        }
    }
    foreground = float4(clamp(minFgdCoc, -1, 0), clamp(maxFgdCoc, -1, 0), 0, 0);
    background = float4(clamp(minBgdCoc, 0, 1), clamp(maxBgdCoc, 0, 1), 0, 0);
}


float4 CocDilateMainVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * CocTileScale);
	oTexcoord1 = focalCameraParams;
	return Position;
}

void CocDilateMainPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    out float4 foreground : COLOR0,
    out float4 background : COLOR1)
{
    foreground = tex2Dlod(TileOutputForegroundSampler, float4(coord, 0, 0));
    background = tex2Dlod(TileOutputBackgroundSampler, float4(coord, 0, 0));
}

float4 GatherMainVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += float2(0.5, 0.5) / (ViewportSize * CocTileScale);
	oTexcoord1 = focalCameraParams;
	return Position;
}

// Returns the total number of sampling iteration for a given ring id.
int GetRingSamplingPairCount(int RingId)
{
#if KernelSamplingDensityMode == KERNEL_DENSITY_CONSTANT_HEXAWEB || KernelSamplingDensityMode == KERNEL_DENSITY_LOWER_IN_CENTER_HEXAWEB
    return (RingId + 1) * 3;
#else
    // This number of sample is carefully chosen to have exact number of sample a square shaped ring (SquarePos).
    return (RingId + 1) * 4;
#endif
}


// Returns the total number of sample of the kernel.
int GetKernelSampleCount(int RingCount)
{
#if KernelSamplingDensityMode == KERNEL_DENSITY_CONSTANT_HEXAWEB || KernelSamplingDensityMode == KERNEL_DENSITY_LOWER_IN_CENTER_HEXAWEB
    return 1 + 3 * RingCount * (RingCount + 1);
#else
	// Depends on GetRingSamplingPairCount().
	return 1 + 4 * RingCount * (RingCount + 1);
#endif
}

// Returns the position of the sample on the unit circle (radius = 1) for a given ring.
float2 GetDiskSampleOnUnitCirle(int RingId, int RingSampleIteration, int RingSampleId)
{
	float SampleRingPos = RingSampleId;

	// Do not allign all j == 0 samples of the different ring on the X axis to increase minimal distance between all
	// samples, that reduce variance to clean by post filtering.
	SampleRingPos += (RingId - 2 * (RingId / 2)) * 0.5;

	// #if CONFIG_SLIGHT_RING_ROTATION
	// 	SampleRingPos += (RingId + 1) * 0.2;
	// #endif

	float SampleAngle = PI * SampleRingPos / float(RingSampleIteration);
			
	return float2(cos(SampleAngle), sin(SampleAngle));
}

// Returns the rotation matrix to use between sample of the ring.
float2x2 GetSampleRotationMatrix(int RingSampleIteration)
{
	float RotationAngle = PI / float(RingSampleIteration);

	float C = cos(RotationAngle);
	float S = sin(RotationAngle);

	return float2x2(
		float2( C,  S),
		float2(-S,  C));
}

// Compute sample weight according's to its Coc radius.
float ComputeSampleWeight(float CocRadius)
{
	#if 1
		const float PixelRadius = 0.25; // = 0.5 / CocDownresSample;
		return min(rcp(PI * CocRadius * CocRadius), rcp(PI * PixelRadius * PixelRadius));

	#else
		return 1.0;
	#endif
}

float ComputeForegroundFading(float MaxRecombineAbsCocRadius, float CocRadius)
{
	return saturate((-CocRadius) - (MaxRecombineAbsCocRadius - 1.0));
}

/** Informations about a ring. */
struct FGatherRingInfos
{
	/** Id of the ring. 0 is the smallest ring after the center sample. */
	uint RingId;

	/** Total number of samples on the ring. */
	uint SampleCount;

	/** Compile time constant on whether this is the first accumualted ring. */
	bool bIsFirstRing;

	// Total weight of the ring.
	float Weight;

	/** Radius of the ring in pixels from the center of the kernel. */
	float Radius;
};

/** Structs that holds data about a sample for gathering. */
struct FGatherSample
{
	// Sample's scene color (and optionally alpha channel).
	float4 Color;

	// Sample's radius of the Coc
	float CocRadius;

	// Sample distance from center of kernel, in CocRadius unit.
	float Distance;

	// Sample's intersection.
	float Intersection;
};

/** Accumulator of all gathered samples. */
struct FGatherAccumulator
{
    // Accumulated results for background reconstruction.
    // float4 BackgroundReconstruction; // TODO.

    // Accumulated results for previous bucket.
    float4 PreviousColor;
    float PreviousCocRadius;
    float PreviousCocRadiusSquare;
    float PreviousWeight;

    // Accumulating results for current bucket.
    float4 CurrentColor;
    float CurrentCocRadius;
    float CurrentCocRadiusSquare;
    float CurrentWeight;
    
    float CurrentTranslucency;

    // The bordering radius between current and previous buckets.
    float BorderingRadius;

    bool bIsFirstRing;

    float FarBorderingRadius;
    float CloseBorderingRadius;
};

FGatherAccumulator CreateGatherAccumulator()
{
	FGatherAccumulator Accumulator;

    Accumulator.PreviousColor = 0;
    Accumulator.PreviousCocRadius = 0;
    Accumulator.PreviousCocRadiusSquare = 0;
    Accumulator.PreviousWeight = 0;

    Accumulator.CurrentColor = 0;
    Accumulator.CurrentCocRadius = 0;
    Accumulator.CurrentCocRadiusSquare = 0;
    Accumulator.CurrentWeight = 0;

    Accumulator.CurrentTranslucency = 0;

    Accumulator.FarBorderingRadius = 0;
    Accumulator.CloseBorderingRadius = 0;

    Accumulator.BorderingRadius = 0;
    Accumulator.bIsFirstRing = false;

	return Accumulator;
}


/** Merge current bucket into the previous bucket. */
void MergeCurrentBucketIntoPreviousBucket(inout FGatherAccumulator Accumulator, float SampleCount)
{
	// If have not accumulated any sample into the current bucket, just avoid this useless work and the
	// NaNs that would be coming with.
	if (Accumulator.CurrentWeight == 0.0)
	{
		return;
	}

	// Opacity of the current bucket.
	float CurrentRingOpacity = saturate(1 - Accumulator.CurrentTranslucency * rcp(SampleCount));
	
	// Compute current and previous Coc radii.
	float PreviousCocRadius = Accumulator.PreviousCocRadius * rcp(Accumulator.PreviousWeight);
	float CurrentCocRadius = Accumulator.CurrentCocRadius * rcp(Accumulator.CurrentWeight);

	// Whether current bucket is occluding previous bucket.
	// TODO: put a contrast.
	float bOccludingCoc = saturate((PreviousCocRadius - CurrentCocRadius));

	// Compute final factor to use to with previous bucket.
	float PreviousBucketFactor = (Accumulator.PreviousWeight == 0.0) ? 0.0 : (1.0 - CurrentRingOpacity * bOccludingCoc);

	// Compose current ring into previous.
	Accumulator.PreviousColor     = Accumulator.PreviousColor     * PreviousBucketFactor + Accumulator.CurrentColor;
	Accumulator.PreviousCocRadius = Accumulator.PreviousCocRadius * PreviousBucketFactor + Accumulator.CurrentCocRadius;
	Accumulator.PreviousCocRadiusSquare = Accumulator.PreviousCocRadiusSquare * PreviousBucketFactor + Accumulator.CurrentCocRadiusSquare;
	Accumulator.PreviousWeight    = Accumulator.PreviousWeight    * PreviousBucketFactor + Accumulator.CurrentWeight;
}

/** Accumulates sample. */
void AccumulateSample(inout FGatherAccumulator Accumulator, in FGatherSample A, float Weight)
{
	// Fade intersection if sample's Coc radius is out of the gathering pass coc bounds.
	float IsConsidered = 1; // IsConsideredCocRadius(Accumulator.GatherParameters, A.CocRadius);
	
	// Compare the sample's Coc radius with the bucket bordering radius.
	float bBelongsToPrevious = saturate(A.CocRadius - Accumulator.BorderingRadius + 0.5);

	// First ring is directly accumulated to the current bucket, because merge with potential larger .
	if (Accumulator.bIsFirstRing)
	{
		bBelongsToPrevious = 0.0;
	}

	float bBelongsToCurrent = 1.0 - bBelongsToPrevious;

	if (!Accumulator.bIsFirstRing)
	{
		float M = 1;
		M *= 1 - saturate(A.CocRadius - Accumulator.FarBorderingRadius + 0.5);
		M *= saturate(A.CocRadius - Accumulator.CloseBorderingRadius + 0.5);

		bBelongsToCurrent *= saturate(A.CocRadius - Accumulator.CloseBorderingRadius + 0.5);
		bBelongsToPrevious *= 1 - saturate(A.CocRadius - Accumulator.FarBorderingRadius + 0.5);
	}

	float CurrentWeight = (A.Intersection * IsConsidered * Weight) * bBelongsToCurrent;

	Accumulator.CurrentColor += A.Color * CurrentWeight;
	Accumulator.CurrentCocRadius += A.CocRadius * CurrentWeight;
	Accumulator.CurrentCocRadiusSquare += A.CocRadius * (A.CocRadius * CurrentWeight);
	Accumulator.CurrentWeight += CurrentWeight;
	
	float PreviousWeight = (A.Intersection * IsConsidered * Weight) * bBelongsToPrevious;

	Accumulator.PreviousColor += A.Color * PreviousWeight;
	Accumulator.PreviousCocRadius += A.CocRadius * PreviousWeight;
	Accumulator.PreviousCocRadiusSquare += A.CocRadius * (A.CocRadius * PreviousWeight);
	Accumulator.PreviousWeight += PreviousWeight;

	// Accumulate current bucket translucency.
	{
		float SampleTranslucency = saturate(A.CocRadius - Accumulator.BorderingRadius);

		//Accumulator.CurrentTranslucency += A.CocRadius > Accumulator.BorderingRadius;
		Accumulator.CurrentTranslucency += SampleTranslucency;
	}
}

/** Accumulates center sample. */
void AccumulateCenterSample(inout FGatherAccumulator Accumulator, in FGatherSample A)
{
	// Fade intersection as CocRadius becomes close to 0 to fallback to full resolution gathering.	
	A.Intersection *= ComputeForegroundFading(3/4, A.CocRadius);

	// TODO: when accumulating the foreground, there is an issue in geometric edges.
	#if 1
		float WeightA = ComputeSampleWeight(A.CocRadius);
		AccumulateSample(Accumulator, A, WeightA);
		// Accumulator.bIsHoleFillingForForeground = IsForeground(A.CocRadius);
		// Accumulator.CenterCocRadius = A.CocRadius;
	#endif
}

void AccumulateCenterSampleAsItsOwnRing(inout FGatherAccumulator Accumulator, in FGatherSample A)
{
	AccumulateCenterSample(/* inout */ Accumulator, A);
}

/** Accumulates mirror samples. */
void AccumulateMirrorSamples(inout FGatherAccumulator Accumulator, in FGatherSample A, in FGatherSample B)
{	
	float WeightA = ComputeSampleWeight(A.CocRadius);
	float WeightB = ComputeSampleWeight(B.CocRadius);

    // Fade intersection as CocRadius becomes close to 0 to fallback to full resolution gathering.	
    A.Intersection *= ComputeForegroundFading(3/4, A.CocRadius);
    B.Intersection *= ComputeForegroundFading(3/4, B.CocRadius);

    // Hole filling for foreground pixels.
	#if 1
	{
		if (IsForeground(A.CocRadius) && B.CocRadius > A.CocRadius)
		{
			B.Intersection = max(B.Intersection, A.Intersection);
		}
		else if (IsForeground(B.CocRadius) && A.CocRadius > B.CocRadius)
		{
			A.Intersection = max(B.Intersection, A.Intersection);
		}
	}
	#elif 0
	{
		if (B.CocRadius > A.CocRadius)
		{
			B.Intersection = A.Intersection;
			DerivedB.Weight = DerivedA.Weight;
		}
		else
		{
			A.Intersection = B.Intersection;
			DerivedA.Weight = DerivedB.Weight;
		}
	}
	#else
		#error Unimplemented hole filling.
	#endif

	AccumulateSample(Accumulator, A, WeightA);
	AccumulateSample(Accumulator, B, WeightB);
}

// Computes intersection of sample from its Coc and its distance.
// Returns 0: no intersection, 1: intersection.
float ComputeSampleIntersection(float SampleCocRadius, float SampleDistance)
{
	// Intersection of output pixel's disk area with sample's Coc.
	#if 1
		// To have an intersection of 50% when the Sample's Coc radius == SampleDistance to be area conservative
		// with bilinear sampled gathering or hybrid scattering.
		const float Offset = 0.5;

        // Uses a sharper intersection for slight out of focus like Recombine pass since it is being used
        // for full res temporal statbility clamping box, so the aliasing this may introduce at half res is
        // Fine.
        const float Multiplier = 4.0;

		return saturate((abs(SampleCocRadius) - SampleDistance) * Multiplier + Offset);

	// Same as Circle DOF.
	#elif 0
		// 0.5 because Coc radius is at half res, and 0.5 so that the fallof is only the radius of a ful res pixel.
		const float IntersectionSharpen = 0.5 * 0.5;

		// TODO: missing +0.5 to be energy conservative.
		return saturate((abs(SampleCocRadius) - SampleDistance) * IntersectionSharpen);

	#else // Hard cut of.
		if (SampleDistance > abs(SampleCocRadius))
		{
			return 0.0;
		}
		return 1.0;
	#endif
}

void GatherRingSamples(float2 coord, int RingId, float SampleCountToSamplePosition, inout FGatherAccumulator Accumulator)
{
    // Number of sample iteration for this ring.
    const int RingSamplePairCount = GetRingSamplingPairCount(RingId);

    // Number of batch to process.
    const int BatchCount = RingSamplePairCount;

    // Distance of the ring from the center of the kernel in sample count.
    const int RingDistance = RingId + 1;

    float RingRadius = RingDistance * SampleCountToSamplePosition;
    
    // Generate at compile time sample rotation matrix.
    const float2x2 SampleRotationMatrix = GetSampleRotationMatrix(RingSamplePairCount);

    // Generates at compile time first sample location on circle (radius = 1).
    const float2 FirstCircleUnitPos = GetDiskSampleOnUnitCirle(RingId, RingSamplePairCount, /* BatchId = */ 0);

    // Position of the first sample on circle with radius according to KernelRadius.
    float2 FirstCircleSamplePosOffset = FirstCircleUnitPos * RingRadius;

    float2 CurrentCircleUnitPos = FirstCircleUnitPos;
    float2 CurrentCircleSamplePosOffset = FirstCircleSamplePosOffset;

    for (int BatchId = 0; BatchId < BatchCount; BatchId++)
    {
        CurrentCircleUnitPos = mul(CurrentCircleUnitPos, SampleRotationMatrix);
        CurrentCircleSamplePosOffset = mul(CurrentCircleSamplePosOffset, SampleRotationMatrix);
        // Fetches the mirrored samples.
        FGatherSample Sample[2];
        [unroll]
        for (int k = 0; k < 2; k++)
        {
            const float SampleSign = (k == 0) ? 1.0 : -1.0;
            // Swizzle the batch positions' X and Y components.
            float2 CirleUnitPos = CurrentCircleUnitPos * SampleSign;
            float2 CircleSamplePosOffset = CurrentCircleSamplePosOffset * SampleSign;

            float2 SamplePos = coord + float2(CircleSamplePosOffset.x, CircleSamplePosOffset.y * ViewportAspect);
            float backWeight = tex2Dlod(DilateOutputBackgroundSampler, float4(SamplePos, 0, 0)).g;
            float foreWeight = -tex2Dlod(DilateOutputForegroundSampler, float4(SamplePos, 0, 0)).r;
            float CoC = backWeight > -foreWeight ? backWeight : foreWeight;
            float4 color = tex2Dlod(SetupOutputHalfSampler, float4(SamplePos, 0, 0));
            Sample[k].Color = color;
            Sample[k].CocRadius = CoC;
            Sample[k].Distance = RingRadius;
            Sample[k].Intersection = ComputeSampleIntersection(CoC, RingRadius);
        }
        
        AccumulateMirrorSamples(Accumulator, Sample[0], Sample[1]);
    }
}

/** Setup up the accumulator for a ring. */
void StartRingSamples(inout FGatherAccumulator Accumulator, FGatherRingInfos RingInfos)
{
	Accumulator.BorderingRadius = (RingInfos.RingId + (1.5 + CocRadiusError)) * (KernelRadius * rcp(0.5 + MaxRingCount)); 
}

/** Digests all samples accumulated for the ring. */
void EndRingSamples(inout FGatherAccumulator Accumulator, FGatherRingInfos RingInfos)
{
    if (RingInfos.bIsFirstRing)
	{
		// Simply move current bucket into previous bucket.
		Accumulator.PreviousColor     = Accumulator.CurrentColor;
		Accumulator.PreviousCocRadius = Accumulator.CurrentCocRadius;
		Accumulator.PreviousCocRadiusSquare = Accumulator.CurrentCocRadiusSquare;
		Accumulator.PreviousWeight    = Accumulator.CurrentWeight;
    }
    else
    {
        MergeCurrentBucketIntoPreviousBucket(Accumulator, RingInfos.SampleCount);
    }
	
	// Reset current bucket accumulators.
	Accumulator.CurrentColor = 0;
	Accumulator.CurrentCocRadius = 0;
	Accumulator.CurrentCocRadiusSquare = 0;
	Accumulator.CurrentWeight = 0;
	Accumulator.CurrentTranslucency = 0;
}

void GatherRing(float2 coord, int RingId, bool bIsFirstRing, inout FGatherAccumulator Accumulator)
{
    // Number of sample iteration for this ring.
    const int RingSamplePairCount = GetRingSamplingPairCount(RingId);

	// Distance of the ring from the center of the kernel in sample count.
	const int RingDistance = int(RingId + 1);

    // Radius of a sample in the unit circle.
	const float UnitSampleRadius = rcp(MaxRingCount + 0.5);
    float SampleCountToSamplePosition = KernelRadius * UnitSampleRadius;

    FGatherRingInfos RingInfos;
    RingInfos.RingId = RingId;
    RingInfos.SampleCount = 2 * RingSamplePairCount;
    RingInfos.bIsFirstRing = bIsFirstRing;
    RingInfos.Weight = RingInfos.SampleCount * ComputeSampleWeight(RingInfos.Radius);
    RingInfos.Radius = RingDistance * SampleCountToSamplePosition;

    // Start accumulating ring samples
	StartRingSamples(Accumulator, RingInfos);

	GatherRingSamples(coord, RingId, SampleCountToSamplePosition, Accumulator);
	
	// End accumulating ring samples.
	EndRingSamples(Accumulator, RingInfos);
}

void GatherMainPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    out float4 sceneColor : COLOR0,
    out float4 separateAlpha : COLOR1)
{
    sceneColor = 0;
    separateAlpha = 0;

    FGatherAccumulator Accumulator = CreateGatherAccumulator();

    // Computes compile time known values about radius changes
    const float DensityChangeRingCount = MaxRingCount / 2;
	const float LargeKernelRadius = 1 + 2 * MaxRingCount;
	const float SmallKernelRadius = 1 + 2 * (MaxRingCount - DensityChangeRingCount);

	const float RadiusDownScaleFactor = SmallKernelRadius / LargeKernelRadius;

    Accumulator.CloseBorderingRadius = ((MaxRingCount - DensityChangeRingCount) + (0.5 + CocRadiusError)) * (KernelRadius * rcp(0.5 + MaxRingCount));
    Accumulator.FarBorderingRadius = Accumulator.CloseBorderingRadius/ RadiusDownScaleFactor;

    // Sample Coc tile texture.
    for (int RingId = MaxRingCount - 1; RingId >= 0; RingId--)
    {
        // Sample Ring
        GatherRing(
            coord,
            RingId,
            RingId == MaxRingCount - 1, 
            Accumulator
        );
    }

    float backWeight = tex2Dlod(DilateOutputBackgroundSampler, float4(coord, 0, 0)).g;
    float foreWeight = -tex2Dlod(DilateOutputForegroundSampler, float4(coord, 0, 0)).r;
    float CoC = backWeight > -foreWeight ? backWeight : foreWeight;
    float4 color = tex2Dlod(SetupOutputHalfSampler, float4(coord, 0, 0));

    FGatherSample CenterSample;
    CenterSample.Color = color;
    CenterSample.CocRadius = CoC;
    CenterSample.Distance = 0;
    CenterSample.Intersection = ComputeSampleIntersection(CoC, 0);
    AccumulateCenterSampleAsItsOwnRing(Accumulator, CenterSample);

    sceneColor = Accumulator.PreviousColor * rcp(Accumulator.PreviousWeight); // Accumulator.PreviousColor;
}

float4 DOFOutputVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float2 oTexcoord0 : TEXCOORD0,
	out float4 oTexcoord1 : TEXCOORD1) : POSITION
{
	float focalDistance = mFocalDistance;
	float focalLength = GetFocalLength(GetCameraFocalLength(), focalDistance);
	float focalAperture = GetFocalAperture(mFstop);
	float4 focalCameraParams = float4(focalDistance, focalLength, focalAperture, 1);

	oTexcoord0 = Texcoord.xy;
	oTexcoord0.xy += ViewportOffset;
	oTexcoord1 = focalCameraParams;
	return Position;
}

float4 DOFOutputPS(
	in float2 coord : TEXCOORD0,
    in float4 focalCameraParams : TEXCOORD1,
    uniform sampler source): COLOR
{
	// float3 color = tex2Dlod(SetupOutputHalfSampler, float4(coord, 0, 0)).rgb;
	// float coc = tex2Dlod(SetupOutputHalfSampler, float4(coord, 0, 0)).a / 10;
	// return float4(coc, coc, coc, 1.0);

	// float2 minMaxBgdCoc = tex2Dlod(DilateOutputBackgroundSampler, float4(coord, 0, 0)).rg / 10;
    // float2 minMaxFgdCoc = tex2Dlod(DilateOutputForegroundSampler, float4(coord, 0, 0)).rg / 10;
	// return float4(abs(minMaxFgdCoc.r), minMaxBgdCoc.g, 0.0, 1.0);
    float4 color = tex2Dlod(ConvolutionOutputSceneColorSampler, float4(coord, 0, 0));
    return float4(color.r, color.g, color.b, 1.0);
}

